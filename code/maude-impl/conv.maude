in structs

fmod AST-CONVERSION-IN is
    pr AST .
    pr EPEG .
    sort ConvReturn .
    op _|%|_ : Graph Node -> ConvReturn [ctor prec 42] .
    op graphPart : ConvReturn -> Graph .
    op nodePart : ConvReturn -> Node .
    op convert : System -> EPeg .
    op addConv : System Graph -> ConvReturn .
    op addConv : Rule Graph -> ConvReturn [ditto] .
    op addConv : Var Graph -> ConvReturn .
    op addConv : Term Graph -> ConvReturn [ditto] .
    op addConvAux : Term Graph Nat -> ConvReturn .
    op trivClasses : Graph -> EquivClasses .
    vars N N0 N1 N2 : Node .
    vars ND0 ND1 : NodeData .
    var E : Edge .
    var ED : EdgeData .
    vars G G0 G1 : Graph .
    var S : System .
    var R : Rule .
    var EQ : Equation .
    vars T T0 T1 : Term .
    var Q : Qid .
    vars I J K : Nat .
    var TL : TermList .
    var O : Operation .
    var V : Var .
    var ECS : EquivClasses .
    eq graphPart(G |%| N) = G .
    eq nodePart(G |%| N) = N .
    ceq convert(S) = G *! trivClasses(G) if G := graphPart(addConv(S, empty)) .
    eq addConv(emptySys, (I @ sysD through nothing to N ; G)) = (I @ sysD into N ; G) |%| I @ sysD .
    eq addConv(emptySys, empty) = empty |%| 0 @ sysD .
    ceq addConv((R ; S), G) = addConv(S, G0)
      if G0 |%| N := addConv(R, G) .
    eq addConv((EQ ; S), G) = addConv(S, G) .
    ceq addConv((T0 ==> T1), (I @ sysD through nothing to N2 ; G)) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; I @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, (I @ sysD into N2 ; G)) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ anonRuleD .
    ceq addConv((T0 ==> T1), empty) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; 0 @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, empty) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ anonRuleD .
    ceq addConv((T0 =[ Q ]=> T1), (I @ sysD through nothing to N2 ; G)) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; I @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, (I @ sysD into N2 ; G)) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ namedRuleD(Q) .
    ceq addConv((T0 =[ Q ]=> T1), empty) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; 0 @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, empty) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ namedRuleD(Q) .
    eq addConv((O ! TL), G) = addConvAux((O ! TL), G, 0) .
    eq addConvAux((oper(Q) ! nil), G, K) = G |%| nextId(G) @ operD(Q) .
    ceq addConvAux((oper(Q) ! (T , TL)), G, K) = G1 ; N through K to N0 |%| N
      if G0 |%| N0 := addConv(T, G) /\ G1 |%| N := addConvAux((oper(Q) ! TL), G0, K + 1) .
    eq addConv(var(Q), G) = G |%| nextId(G) @ varD(Q) .
    ceq trivClasses(E) = N0 , N1
      if N0 through ED to N1 := E .
    ceq trivClasses(E ; G) = N0 , N1 , ECS
      if N0 through ED to N1 := E /\ ECS := trivClasses(G) .
endfm

fmod AST-CONVERSION-OUT is
    pr AST .
    pr EPEG .
    sorts SystemSet RuleSet TermSet MaybeNode NodeList .
    subsorts System < SystemSet .
    subsorts Rule < RuleSet .
    subsorts Term < TermSet .
    subsorts Node < MaybeNode < NodeList .
    op extractAll : EPeg -> SystemSet .
    op findSystemClass : EquivClasses -> EquivClass .
    op findClassOf : EquivClasses Node -> EquivClass .
    op extractSystemUnder : EPeg Node -> System .
    op extractSystemsUnder : EPeg EquivClass -> SystemSet .
    op extractRuleUnder : EPeg Node -> Rule .
    op extractRulesUnder : EPeg Node -> RuleSet .
    op extractTermUnder : EPeg Node -> Term .
    op extractTermsUnder : EPeg Node -> TermSet .
    op extractTermListUnder : EPeg NodeList -> TermList .
    op childrenOf : Graph Node -> NodeList .
    op childrenOfAt : Graph Node Nat -> NodeList .
    op __ : SystemSet SystemSet -> SystemSet [ctor assoc comm prec 44] .
    op __ : RuleSet RuleSet -> RuleSet [ctor assoc comm prec 44] .
    op __ : TermSet TermSet -> TermSet [ctor assoc comm prec 44] .
    op null : -> MaybeNode [ctor] .
    op _;_ : NodeList NodeList -> NodeList [ctor assoc prec 44 id: null] .
    var EP : EPeg .
    vars G G0 : Graph .
    vars EC EC0 : EquivClass .
    var ECS : EquivClasses .
    vars I J K : Nat .
    vars N N0 : Node .
    var ND : NodeData .
    var ED : EdgeData .
    var Q : Qid .
    var S : System .
    var R : Rule .
    var T : Term .
    var NL : NodeList .
    eq S S = S .
    eq R R = R .
    eq T T = T .
    ceq extractAll(EP) = extractSystemsUnder(EP, findSystemClass(ECS))
      if G *! ECS := EP .
    eq findSystemClass(((I @ sysD) EC , ECS)) = (I @ sysD) EC .
    eq findSystemClass(((I @ sysD) EC)) = (I @ sysD) EC .
    eq findSystemClass((I @ sysD , ECS)) = I @ sysD .
    eq findSystemClass(I @ sysD) = I @ sysD .
    eq findClassOf((N EC , ECS), N) = N EC .
    eq findClassOf((N EC), N) = N EC .
    eq findClassOf((N , ECS), N) = N .
    eq findClassOf(N, N) = N .
    eq extractTermUnder(G *! (I @ varD(Q) , ECS), I @ varD(Q)) = var(Q) .
    eq extractTermUnder(G *! (I @ varD(Q) EC , ECS), I @ varD(Q)) = var(Q) .
    eq extractTermUnder(G *! (I @ operD(Q) , ECS), I @ operD(Q)) = oper(Q) ! extractTermListUnder(G *! (I @ operD(Q) , ECS), childrenOf(G, I @ operD(Q))) .
    eq extractTermUnder(G *! (I @ operD(Q) EC , ECS), I @ operD(Q)) = oper(Q) ! extractTermListUnder(G *! (I @ operD(Q) EC , ECS), childrenOf(G, I @ operD(Q))) .
    eq extractTermListUnder(EP, null) = nil .
    eq extractTermListUnder(EP, N ; NL) = extractTermUnder(EP, N) , extractTermListUnder(EP, NL) .
    eq childrenOf(I @ sysD through nothing to N ; G, I @ sysD) = N ; childrenOf(G, I @ sysD) .
    eq childrenOf(N through 0 to N0 ; G, N) = N0 ; childrenOfAt(G, N, 1) .
    eq childrenOf(G, N) = null [owise] .
    eq childrenOfAt(N through K to N0 ; G, N, K) = N0 ; childrenOfAt(G, N, K + 1) .
    eq childrenOfAt(G, N, K) = null [owise] .
endfm
