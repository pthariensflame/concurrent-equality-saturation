in structs

fmod AST-CONVERSION-IN is
    pr AST .
    pr EPEG .
    sort ConvReturn .
    op _|%|_ : Graph Node -> ConvReturn [ctor prec 42] .
    op graphPart : ConvReturn -> Graph .
    op nodePart : ConvReturn -> Node .
    op convert : System -> EPeg .
    op addConv : System Graph -> ConvReturn .
    op addConv : Rule Graph -> ConvReturn [ditto] .
    op addConv : Var Graph -> ConvReturn .
    op addConv : Term Graph -> ConvReturn [ditto] .
    op addConvAux : Term Graph Nat -> ConvReturn .
    op trivClasses : Graph -> EquivClasses .
    vars N N0 N1 N2 : Node .
    vars ND0 ND1 : NodeData .
    var E : Edge .
    var ED : EdgeData .
    vars G G0 G1 : Graph .
    var S : System .
    var R : Rule .
    var EQ : Equation .
    vars T T0 T1 : Term .
    var Q : Qid .
    vars I J K : Nat .
    var TL : TermList .
    var O : Operation .
    var V : Var .
    var ECS : EquivClasses .
    eq graphPart(G |%| N) = G .
    eq nodePart(G |%| N) = N .
    ceq convert(S) = G *! trivClasses(G) if G := graphPart(addConv(S, empty)) .
    eq addConv(emptySys, (I @ sysD through nothing to N ; G)) = (I @ sysD into N ; G) |%| I @ sysD .
    eq addConv(emptySys, empty) = empty |%| 0 @ sysD .
    ceq addConv((R ; S), G) = addConv(S, G0)
      if G0 |%| N := addConv(R, G) .
    eq addConv((EQ ; S), G) = addConv(S, G) .
    ceq addConv((T0 ==> T1), (I @ sysD through nothing to N2 ; G)) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; I @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, (I @ sysD into N2 ; G)) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ anonRuleD .
    ceq addConv((T0 ==> T1), empty) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; 0 @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, empty) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ anonRuleD .
    ceq addConv((T0 =[ Q ]=> T1), (I @ sysD through nothing to N2 ; G)) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; I @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, (I @ sysD into N2 ; G)) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ namedRuleD(Q) .
    ceq addConv((T0 =[ Q ]=> T1), empty) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; 0 @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, empty) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ namedRuleD(Q) .
    eq addConv((O ! TL), G) = addConvAux((O ! TL), G, 0) .
    eq addConvAux((oper(Q) ! nil), G, K) = G |%| nextId(G) @ operD(Q) .
    ceq addConvAux((oper(Q) ! (T , TL)), G, K) = G1 ; N through K to N0 |%| N
      if G0 |%| N0 := addConv(T, G) /\ G1 |%| N := addConvAux((oper(Q) ! TL), G0, K + 1) .
    eq addConv(var(Q), G) = G |%| nextId(G) @ varD(Q) .
    ceq trivClasses(E) = I , J
      if I @ ND0 through ED to J @ ND1 := E .
    ceq trivClasses(E ; G) = I , J , ECS
      if I @ ND0 through ED to J @ ND1 := E /\ ECS := trivClasses(G) .
endfm

fmod AST-CONVERSION-OUT is
    pr AST .
    pr EPEG .
    sorts SystemSet RuleSet TermSet .
    subsorts System < SystemSet .
    subsorts Rule < RuleSet .
    subsorts Term < TermSet .
    op extractAll : EPeg -> SystemSet .
    op findSystemClass : EquivClasses -> EquivClass .
    op findClassOf : EquivClasses Nat -> EquivClass .
    op extractSystemUnder : EPeg Nat -> System .
    op extractSystemsUnder : EPeg EquivClass -> SystemSet .
    op extractRuleUnder : EPeg Nat -> Rule .
    op extractRulesUnder : EPeg Nat -> RuleSet .
    op extractTermUnder : EPeg Nat -> Term .
    op extractTermsUnder : EPeg Nat -> TermSet .
    op __ : SystemSet SystemSet -> SystemSet [ctor assoc comm prec 44] .
    op __ : RuleSet RuleSet -> RuleSet [ctor assoc comm prec 44] .
    op __ : TermSet TermSet -> TermSet [ctor assoc comm prec 44] .
    var EP : EPeg .
    vars G G0 : Graph .
    vars EC EC0 : EquivClass .
    var ECS : EquivClasses .
    vars I J K : Nat .
    var N : Node .
    var ND : NodeData .
    var ED : EdgeData .
    var Q : Qid .
    var S : System .
    var R : Rule .
    var T : Term .
    eq S S = S .
    eq R R = R .
    eq T T = T .
    eq extractAll(EP) = extractSystemsUnder(EP, findSystemClass(EP)) .
    eq findSystemClass(ECS) = findClassOf(ECS, 0) .
    eq findClassOf((I EC , ECS), I) = I EC .
    eq findClassOf((I EC), I) = I EC .
    eq findClassOf((I , ECS), I) = I .
    eq findClassOf(I, I) = I .
    eq extractTermUnder((N through K to I @ varD(Q)) ; G *! (I , ECS), I) = varD(Q) .
endfm
