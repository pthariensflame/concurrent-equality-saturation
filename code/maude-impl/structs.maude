fmod AST is
    pr QID .
    sorts System Rule Equation Operation Var Term TermList .
    subsorts Rule Equation < System .
    subsorts Var < Term < TermList .
    op emptySys : -> System [ctor] .
    op _;_ : System System -> System [ctor assoc comm id: emptySys prec 36] .
    op _===_ : Term Term -> Equation [ctor prec 34] .
    op _==>_ : Term Term -> Rule [ctor prec 34] .
    op _=[_]=>_ : Term Qid Term -> Rule [ctor prec 34] .
    op nil : -> TermList [ctor] .
    op _,_ : TermList TermList -> TermList [ctor assoc id: nil prec 30] .
    op var : Qid -> Var [ctor] .
    op oper : Qid -> Operation [ctor] .
    op _!_ : Operation TermList -> Term [ctor prec 32] .
    eq R::Rule ; R::Rule = R::Rule .
    eq E::Equation ; E::Equation = E::Equation .
endfm

fth GRAPH-SPEC is
    sorts NodeData EdgeData .
endfth

fmod EGRAPH{S :: GRAPH-SPEC} is
    pr NAT .
    sorts Node{S} Edge{S} Graph{S} ENode{S} EEdge{S} EGraph{S} .
    subsorts Node{S} < ENode{S} .
    subsorts Edge{S} < Graph{S} EEdge{S} < EGraph{S} .
    op _@_ : Nat S$NodeData -> Node{S} [prec 30] .
    op _through_to_ : ENode{S} S$EdgeData ENode{S} -> EEdge{S} [ctor prec 34] .
    op _through_to_ : Node{S} S$EdgeData Node{S} -> Edge{S} [ctor ditto] .
    op empty : -> Graph{S} [ctor] .
    op _;_ : EGraph{S} EGraph{S} -> EGraph{S} [ctor assoc comm id: empty prec 36] .
    op _;_ : Graph{S} Graph{S} -> Graph{S} [ctor ditto] .
    op _,_ : ENode{S} ENode{S} -> ENode{S} [ctor assoc comm prec 32] .
    ops nextId nextIdAux : EGraph{S} -> Nat .
    vars I0 I1 : Nat .
    vars ND0 ND1 : S$NodeData .
    vars N0 N1 : ENode{S} .
    var ED : S$EdgeData .
    var E : EEdge{S} .
    var G : EGraph{S} .
    eq E ; E = E .
    eq N0 , N0 = N0 .
    eq nextIdAux(empty) = 0 .
    eq nextIdAux(((I0 @ ND0) through ED to (I1 @ ND1)) ; G) = max(max(I0, I1), nextId(G)) .
    eq nextIdAux((((I0 @ ND0) , N0) through ED to ((I1 @ ND1) , N1)) ; G) = max(max(I0, I1), nextId((N0 through ED to N1) ; G)) .
    eq nextId(G) = nextIdAux(G) + 1 .
endfm

fmod PEG-SPEC is
    pr NAT . pr QID .
    sorts SystemD RuleD CompositionD OperationD VarD NodeData Nothing EdgeData .
    subsorts SystemD RuleD CompositionD OperationD VarD < NodeData .
    subsorts Nothing Nat < EdgeData .
    op sysD : -> SystemD [ctor] .
    op anonRuleD : -> RuleD [ctor] .
    op namedRuleD : Qid -> RuleD [ctor] .
    op anonCompD : -> CompositionD [ctor] .
    op namedCompD : Qid -> CompositionD [ctor] .
    op operD : Qid -> OperationD [ctor] .
    op varD : Qid -> OperationD [ctor] .
    op nothing : -> Nothing [ctor] .
endfm

view PEGSpec from GRAPH-SPEC to PEG-SPEC is
endv

fmod EPEG is
    pr PEG-SPEC + EGRAPH{PEGSpec} * (
        sort Node{PEGSpec} to Node,
        sort Edge{PEGSpec} to Edge,
        sort Graph{PEGSpec} to Graph,
        sort ENode{PEGSpec} to ENode,
        sort EEdge{PEGSpec} to EEdge,
        sort EGraph{PEGSpec} to EGraph
    ) .
    op _into_ : ENode ENode -> EEdge [prec 34] .
    op _into_ : Node Node -> Edge [ditto] .
    vars N0 N1 : Node .
    vars EN0 EN1 : ENode .
    eq N0 into N1 = N0 through nothing to N1 .
    eq EN0 into EN1 = EN0 through nothing to EN1 .
endfm

fmod AST-CONVERSION is
    pr AST .
    pr EPEG .
    sort ConvReturn .
    op _|%|_ : Graph Node -> ConvReturn [ctor prec 40] .
    op graphPart : ConvReturn -> Graph .
    op nodePart : ConvReturn -> Node .
    op convert : System -> ConvReturn .
    op addConv : System Graph -> ConvReturn .
    op addConv : Rule Graph -> ConvReturn [ditto] .
    op addConv : Var Graph -> ConvReturn .
    op addConv : Term Graph -> ConvReturn [ditto] .
    op addConvAux : Term Graph Nat -> ConvReturn .
    vars N N0 N1 N2 : Node .
    var E : Edge .
    vars G G0 G1 : Graph .
    var S : System .
    var R : Rule .
    var EQ : Equation .
    vars T T0 T1 : Term .
    var Q : Qid .
    vars I K : Nat .
    var TL : TermList .
    var O : Operation .
    var V : Var .
    eq graphPart(G |%| N) = G .
    eq nodePart(G |%| N) = N .
    eq convert(S) = addConv(S, empty) .
    eq addConv(emptySys, (I @ sysD through nothing to N ; G)) = (I @ sysD into N ; G) |%| I @ sysD .
    eq addConv(emptySys, empty) = empty |%| 0 @ sysD .
    ceq addConv((R ; S), G) = addConv(S, G0)
      if G0 |%| N := addConv(R, G) .
    eq addConv((EQ ; S), G) = addConv(S, G) .
    ceq addConv((T0 ==> T1), (I @ sysD through nothing to N2 ; G)) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; I @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, (I @ sysD into N2 ; G)) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ anonRuleD .
    ceq addConv((T0 ==> T1), empty) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; 0 @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, empty) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ anonRuleD .
    ceq addConv((T0 =[ Q ]=> T1), (I @ sysD through nothing to N2 ; G)) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; I @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, (I @ sysD into N2 ; G)) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ namedRuleD(Q) .
    ceq addConv((T0 =[ Q ]=> T1), empty) = (G1 ; N through 0 to N0 ; N through 1 to N1 ; 0 @ sysD into N) |%| N
      if G0 |%| N0 := addConv(T0, empty) /\ G1 |%| N1 := addConv(T1, G0) /\ N := nextId(G1) @ namedRuleD(Q) .
    eq addConv((O ! TL), G) = addConvAux((O ! TL), G, 0) .
    eq addConvAux((oper(Q) ! nil), G, K) = G |%| nextId(G) @ operD(Q) .
    ceq addConvAux((oper(Q) ! (T , TL)), G, K) = G1 ; N through K to N0 |%| N
      if G0 |%| N0 := addConv(T, G) /\ G1 |%| N := addConvAux((oper(Q) ! TL), G0, K + 1) .
    eq addConv(var(Q), G) = G |%| nextId(G) @ varD(Q) .
endfm
